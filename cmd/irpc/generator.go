package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"log"
	"strings"
)

// id len specifies how long our service's id will be. currently the max is 32 bytes as we are using sha256 to generate them
// actual id to negotiate between endpoints doesn't have to be full lenght (currently it's only 4 bytes)
const generatedIdLen = 32

type generator struct {
	services []apiGenerator
	tr       typeResolver
}

func newGenerator(filename string) (generator, error) {
	var services []apiGenerator

	tr, err := newTypeResolver(filename)
	if err != nil {
		return generator{}, fmt.Errorf("newTypeResolver(): %w", err)
	}

	// INTERFACES
	for _, decl := range tr.srcFileAst.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.TYPE {
			continue
		}
		for _, spec := range genDecl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if iface, ok := ts.Type.(*ast.InterfaceType); ok {
				api, err := newApiGenerator(tr, ts.Name.String(), iface)
				if err != nil {
					return generator{}, fmt.Errorf("new apiGenerator: %w", err)
				}

				services = append(services, api)
			}
		}
	}

	return generator{
		tr:       tr,
		services: services,
	}, nil
}

func newRpcParam(position int, name string, t Type) (rpcParam, error) {
	return rpcParam{
		pos:  position,
		name: name,
		typ:  t,
	}, nil
}

// if hash is nil, we generate service id with empty hash
//   - this is used during first run of generator
func (g generator) generate(w io.Writer, hash []byte) error {
	q := newQualifier(g.tr)
	codeBlocks := newOrderedSet[string]()

	for _, service := range g.services {
		codeBlocks.add(service.serviceCode(hash, q))
		codeBlocks.add(service.clientCode(hash, q))

		for _, p := range service.paramStructs() {
			// we don't generate empty types (even though the generator is capable of generating them)
			// we use irpcgen.Empty(Ser/Deser) instead
			if !p.isEmpty() {
				codeBlocks.add(p.code(q))
				for _, e := range p.encoders() {
					codeBlocks.add(e.codeblock(q))
				}
			}
		}
	}

	// GENERATE
	rawOutput := g.genRaw(codeBlocks, q)

	// FORMAT
	formatted, err := format.Source([]byte(rawOutput))
	if err != nil {
		log.Println("formatting failed. writing raw code to output file anyway")
		if _, err := w.Write([]byte(rawOutput)); err != nil {
			return fmt.Errorf("writing unformatted code to file: %w", err)
		}
	}

	if _, err := w.Write([]byte(formatted)); err != nil {
		return fmt.Errorf("copy of generated code to file: %w", err)
	}

	return nil
}

func (g generator) genRaw(codeBlocks orderedSet[string], q *qualifier) string {
	sb := &strings.Builder{}
	// HEADER
	headerStr := `// Code generated by irpc generator; DO NOT EDIT
	package %s
	`
	fmt.Fprintf(sb, headerStr, g.tr.inputPkg.Name)

	if q.usedImports.len() != 0 {
		sb.WriteString("import(\n")
		for _, imp := range q.usedImports.ordered {
			fmt.Fprintf(sb, "%s \"%s\"\n", imp.alias, imp.path)
		}
		sb.WriteString("\n)\n")
	}

	// UNIQUE BLOCKS
	for _, b := range codeBlocks.ordered {
		fmt.Fprintf(sb, "\n%s\n", b)
	}

	return sb.String()
}
