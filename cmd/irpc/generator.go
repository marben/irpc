package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"log"
	"strings"
)

// id len specifies how long our service's id will be. currently the max is 32 bytes as we are using sha256 to generate them
// actual id to negotiate between endpoints doesn't have to be full lenght (currently it's only 4 bytes)
const generatedIdLen = 32

type generator struct {
	services []apiGenerator
	tr       typeResolver
}

func newGenerator(filename string) (generator, error) {
	var services []apiGenerator

	tr, err := newTypeResolver(filename)
	if err != nil {
		return generator{}, fmt.Errorf("newTypeResolver(): %w", err)
	}

	// INTERFACES
	for _, decl := range tr.srcFileAst.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.TYPE {
			continue
		}
		for _, spec := range genDecl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if iface, ok := ts.Type.(*ast.InterfaceType); ok {
				var doc *ast.CommentGroup
				if ts.Doc != nil {
					doc = ts.Doc
				} else if genDecl.Doc != nil {
					doc = genDecl.Doc
				}
				api, err := newApiGenerator(tr, ts.Name.String(), iface, doc)
				if err != nil {
					return generator{}, fmt.Errorf("new apiGenerator: %w", err)
				}

				services = append(services, api)
			}
		}
	}

	return generator{
		tr:       tr,
		services: services,
	}, nil
}

// if hash is nil, we generate service id with empty hash
//   - this is used during first run of generator
func (g generator) generate(w io.Writer, hash []byte) error {
	q := newQualifier(g.tr)
	codeBlocks := newOrderedSet[string]()

	for _, service := range g.services {
		codeBlocks.add(service.serviceIdVarDefinition(hash))
		codeBlocks.add(service.serviceCode(q))
		codeBlocks.add(service.clientCode(q))

		for _, ps := range service.paramStructs() {
			// we don't generate empty types (even though the generator is capable of generating them)
			// we use irpcgen.Empty(Ser/Deser) instead
			if !ps.isEmpty() {
				codeBlocks.add(ps.code(q))
				for _, e := range ps.types() {
					codeBlocks.add(e.codeblocks(q)...)
				}
			}
		}
	}

	// GENERATE
	rawOutput := g.genFullFile(codeBlocks.ordered, q.usedImports.ordered)

	// FORMAT
	formatted, err := format.Source([]byte(rawOutput))
	if err != nil {
		log.Println("formatting failed. writing raw code to output file anyway")
		if _, err := w.Write([]byte(rawOutput)); err != nil {
			return fmt.Errorf("writing unformatted code to file: %w", err)
		}
	}

	if _, err := w.Write([]byte(formatted)); err != nil {
		return fmt.Errorf("copy of generated code to file: %w", err)
	}

	return nil
}

// genFullFile generates the whole file including imports etc
// it doesn't do the formatting
func (g generator) genFullFile(codeBlocks []string, imps []importSpec) string {
	sb := &strings.Builder{}
	sb.WriteString("// Code generated by irpc generator; DO NOT EDIT\n")
	fmt.Fprintf(sb, "// Source: %s\n", g.tr.srcFilePath)
	fmt.Fprintf(sb, "package %s\n", g.tr.srcPkg.Name)

	if len(imps) != 0 {
		sb.WriteString("import(\n")
		for _, imp := range imps {
			fmt.Fprintf(sb, "%s \"%s\"\n", imp.alias, imp.path)
		}
		sb.WriteString("\n)\n")
	}

	// UNIQUE BLOCKS
	for _, b := range codeBlocks {
		fmt.Fprintf(sb, "\n%s\n", b)
	}

	return sb.String()
}
